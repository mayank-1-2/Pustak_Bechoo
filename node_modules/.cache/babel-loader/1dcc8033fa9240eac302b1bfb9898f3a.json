{"ast":null,"code":"import { count_occurences } from './helpers';\nimport close_braces from './close braces'; // Takes a `template` where character placeholders\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\n//\n// Returns a function which takes `value` characters\n// and returns the `template` filled with those characters.\n// If the `template` can only be partially filled\n// then it is cut off.\n//\n// If `should_close_braces` is `true`,\n// then it will also make sure all dangling braces are closed,\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\n//\n\nexport default function (template) {\n  var placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  var should_close_braces = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (!template) {\n    return function (value) {\n      return {\n        text: value\n      };\n    };\n  }\n\n  var characters_in_template = count_occurences(placeholder, template);\n  return function (value) {\n    if (!value) {\n      return {\n        text: '',\n        template: template\n      };\n    }\n\n    var value_character_index = 0;\n    var filled_in_template = ''; // Using `.split('')` here instead of normal `for ... of`\n    // because the importing application doesn't neccessarily include an ES6 polyfill.\n    // The `.split('')` approach discards \"exotic\" UTF-8 characters\n    // (the ones consisting of four bytes)\n    // but template placeholder characters don't fall into that range\n    // and appending UTF-8 characters to a string in parts still works.\n\n    for (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var character = _ref;\n\n      if (character !== placeholder) {\n        filled_in_template += character;\n        continue;\n      }\n\n      filled_in_template += value[value_character_index];\n      value_character_index++; // If the last available value character has been filled in,\n      // then return the filled in template\n      // (either trim the right part or retain it,\n      //  if no more character placeholders in there)\n\n      if (value_character_index === value.length) {\n        // If there are more character placeholders\n        // in the right part of the template\n        // then simply trim it.\n        if (value.length < characters_in_template) {\n          break;\n        }\n      }\n    }\n\n    if (should_close_braces) {\n      filled_in_template = close_braces(filled_in_template, template);\n    }\n\n    return {\n      text: filled_in_template,\n      template: template\n    };\n  };\n} //# sourceMappingURL=template formatter.js.map","map":{"version":3,"sources":["C:/Users/MAYANK/Desktop/startup/react/my-app/node_modules/input-format/modules/template formatter.js"],"names":["count_occurences","close_braces","template","placeholder","arguments","length","undefined","should_close_braces","value","text","characters_in_template","value_character_index","filled_in_template","_iterator","split","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","character"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,WAAjC;AACA,OAAOC,YAAP,MAAyB,gBAAzB,C,CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAUC,QAAV,EAAoB;AACjC,MAAIC,WAAW,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAAtF;AACA,MAAIG,mBAAmB,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,GAAuBD,SAAS,CAAC,CAAD,CAAhC,GAAsCE,SAAhE;;AAEA,MAAI,CAACJ,QAAL,EAAe;AACb,WAAO,UAAUM,KAAV,EAAiB;AACtB,aAAO;AACLC,QAAAA,IAAI,EAAED;AADD,OAAP;AAGD,KAJD;AAKD;;AAED,MAAIE,sBAAsB,GAAGV,gBAAgB,CAACG,WAAD,EAAcD,QAAd,CAA7C;AACA,SAAO,UAAUM,KAAV,EAAiB;AACtB,QAAI,CAACA,KAAL,EAAY;AACV,aAAO;AACLC,QAAAA,IAAI,EAAE,EADD;AAELP,QAAAA,QAAQ,EAAEA;AAFL,OAAP;AAID;;AAED,QAAIS,qBAAqB,GAAG,CAA5B;AACA,QAAIC,kBAAkB,GAAG,EAAzB,CATsB,CASO;AAC7B;AACA;AACA;AACA;AACA;;AAEA,SAAK,IAAIC,SAAS,GAAGX,QAAQ,CAACY,KAAT,CAAe,EAAf,CAAhB,EAAoCC,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcJ,SAAd,CAA/C,EAAyEK,EAAE,GAAG,CAA9E,EAAiFL,SAAS,GAAGE,QAAQ,GAAGF,SAAH,GAAeA,SAAS,CAACM,MAAM,CAACC,QAAR,CAAT,EAAzH,IAAyJ;AACvJ,UAAIC,IAAJ;;AAEA,UAAIN,QAAJ,EAAc;AACZ,YAAIG,EAAE,IAAIL,SAAS,CAACR,MAApB,EAA4B;AAC5BgB,QAAAA,IAAI,GAAGR,SAAS,CAACK,EAAE,EAAH,CAAhB;AACD,OAHD,MAGO;AACLA,QAAAA,EAAE,GAAGL,SAAS,CAACS,IAAV,EAAL;AACA,YAAIJ,EAAE,CAACK,IAAP,EAAa;AACbF,QAAAA,IAAI,GAAGH,EAAE,CAACV,KAAV;AACD;;AAED,UAAIgB,SAAS,GAAGH,IAAhB;;AAEA,UAAIG,SAAS,KAAKrB,WAAlB,EAA+B;AAC7BS,QAAAA,kBAAkB,IAAIY,SAAtB;AACA;AACD;;AAEDZ,MAAAA,kBAAkB,IAAIJ,KAAK,CAACG,qBAAD,CAA3B;AACAA,MAAAA,qBAAqB,GApBkI,CAoB9H;AACzB;AACA;AACA;;AAEA,UAAIA,qBAAqB,KAAKH,KAAK,CAACH,MAApC,EAA4C;AAC1C;AACA;AACA;AACA,YAAIG,KAAK,CAACH,MAAN,GAAeK,sBAAnB,EAA2C;AACzC;AACD;AACF;AACF;;AAED,QAAIH,mBAAJ,EAAyB;AACvBK,MAAAA,kBAAkB,GAAGX,YAAY,CAACW,kBAAD,EAAqBV,QAArB,CAAjC;AACD;;AAED,WAAO;AACLO,MAAAA,IAAI,EAAEG,kBADD;AAELV,MAAAA,QAAQ,EAAEA;AAFL,KAAP;AAID,GA3DD;AA4DD,C,CACD","sourcesContent":["import { count_occurences } from './helpers';\nimport close_braces from './close braces'; // Takes a `template` where character placeholders\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\n//\n// Returns a function which takes `value` characters\n// and returns the `template` filled with those characters.\n// If the `template` can only be partially filled\n// then it is cut off.\n//\n// If `should_close_braces` is `true`,\n// then it will also make sure all dangling braces are closed,\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\n//\n\nexport default function (template) {\n  var placeholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  var should_close_braces = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (!template) {\n    return function (value) {\n      return {\n        text: value\n      };\n    };\n  }\n\n  var characters_in_template = count_occurences(placeholder, template);\n  return function (value) {\n    if (!value) {\n      return {\n        text: '',\n        template: template\n      };\n    }\n\n    var value_character_index = 0;\n    var filled_in_template = ''; // Using `.split('')` here instead of normal `for ... of`\n    // because the importing application doesn't neccessarily include an ES6 polyfill.\n    // The `.split('')` approach discards \"exotic\" UTF-8 characters\n    // (the ones consisting of four bytes)\n    // but template placeholder characters don't fall into that range\n    // and appending UTF-8 characters to a string in parts still works.\n\n    for (var _iterator = template.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var character = _ref;\n\n      if (character !== placeholder) {\n        filled_in_template += character;\n        continue;\n      }\n\n      filled_in_template += value[value_character_index];\n      value_character_index++; // If the last available value character has been filled in,\n      // then return the filled in template\n      // (either trim the right part or retain it,\n      //  if no more character placeholders in there)\n\n      if (value_character_index === value.length) {\n        // If there are more character placeholders\n        // in the right part of the template\n        // then simply trim it.\n        if (value.length < characters_in_template) {\n          break;\n        }\n      }\n    }\n\n    if (should_close_braces) {\n      filled_in_template = close_braces(filled_in_template, template);\n    }\n\n    return {\n      text: filled_in_template,\n      template: template\n    };\n  };\n}\n//# sourceMappingURL=template formatter.js.map"]},"metadata":{},"sourceType":"module"}