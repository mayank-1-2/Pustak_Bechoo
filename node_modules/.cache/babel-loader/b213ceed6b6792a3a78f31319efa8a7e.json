{"ast":null,"code":"import edit from './edit';\nimport parse from './parse';\nimport format from './format';\nimport { getOperation, getSelection, getCaretPosition, setCaretPosition } from './dom';\nexport function onCut(event, input, _parse, _format, on_change) {\n  // The actual cut hasn't happened just yet hence the timeout.\n  setTimeout(function () {\n    return format_input_text(input, _parse, _format, undefined, on_change);\n  }, 0);\n}\nexport function onPaste(event, input, _parse, _format, on_change) {\n  var selection = getSelection(input); // If selection is made,\n  // just erase the selected text\n  // prior to pasting\n\n  if (selection) {\n    erase_selection(input, selection);\n  }\n\n  format_input_text(input, _parse, _format, undefined, on_change);\n}\nexport function onChange(event, input, _parse, _format, on_change) {\n  format_input_text(input, _parse, _format, undefined, on_change);\n} // Intercepts \"Delete\" and \"Backspace\" keys.\n// (hitting \"Delete\" or \"Backspace\" at any caret\n//  position should always result in rasing a digit)\n\nexport function onKeyDown(event, input, _parse, _format, on_change) {\n  var operation = getOperation(event);\n\n  switch (operation) {\n    case 'Delete':\n    case 'Backspace':\n      // Intercept this operation and perform it manually.\n      event.preventDefault();\n      var selection = getSelection(input); // If selection is made,\n      // just erase the selected text,\n      // and don't apply any more operations to it.\n\n      if (selection) {\n        erase_selection(input, selection);\n        return format_input_text(input, _parse, _format, undefined, on_change);\n      } // Else, perform the (character erasing) operation manually\n\n\n      return format_input_text(input, _parse, _format, operation, on_change);\n\n    default: // Will be handled when `onChange` fires.\n\n  }\n}\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\n\nfunction erase_selection(input, selection) {\n  var text = input.value;\n  text = text.slice(0, selection.start) + text.slice(selection.end);\n  input.value = text;\n  setCaretPosition(input, selection.start);\n}\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\n\n\nfunction format_input_text(input, _parse, _format, operation, on_change) {\n  // Parse `<input/>` textual value.\n  // Get `value` and `caret` position.\n  var _parse2 = parse(input.value, getCaretPosition(input), _parse),\n      value = _parse2.value,\n      caret = _parse2.caret; // If a user performed an operation (e.g. \"Backspace\", \"Delete\")\n  // then apply that operation and get new `value` and `caret` position.\n\n\n  if (operation) {\n    var operation_applied = edit(value, caret, operation);\n    value = operation_applied.value;\n    caret = operation_applied.caret;\n  } // Format the `value`.\n  // (and reposition the caret accordingly)\n\n\n  var formatted = format(value, caret, _format);\n  var text = formatted.text;\n  caret = formatted.caret; // Set `<input/>` textual value manually\n  // to prevent React from resetting the caret position\n  // later inside subsequent `render()`.\n  // Doesn't work for custom `inputComponent`s for some reason.\n\n  input.value = text; // Position the caret properly.\n\n  setCaretPosition(input, caret); // `<input/>` textual value may have changed,\n  // so the parsed `value` may have changed too.\n  // The `value` didn't neccessarily change\n  // but it might have.\n\n  on_change(value);\n} //# sourceMappingURL=input control.js.map","map":{"version":3,"sources":["C:/Users/MAYANK/Desktop/startup/react/my-app/node_modules/input-format/modules/input control.js"],"names":["edit","parse","format","getOperation","getSelection","getCaretPosition","setCaretPosition","onCut","event","input","_parse","_format","on_change","setTimeout","format_input_text","undefined","onPaste","selection","erase_selection","onChange","onKeyDown","operation","preventDefault","text","value","slice","start","end","_parse2","caret","operation_applied","formatted"],"mappings":"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","sourcesContent":["import edit from './edit';\nimport parse from './parse';\nimport format from './format';\nimport { getOperation, getSelection, getCaretPosition, setCaretPosition } from './dom';\nexport function onCut(event, input, _parse, _format, on_change) {\n  // The actual cut hasn't happened just yet hence the timeout.\n  setTimeout(function () {\n    return format_input_text(input, _parse, _format, undefined, on_change);\n  }, 0);\n}\nexport function onPaste(event, input, _parse, _format, on_change) {\n  var selection = getSelection(input); // If selection is made,\n  // just erase the selected text\n  // prior to pasting\n\n  if (selection) {\n    erase_selection(input, selection);\n  }\n\n  format_input_text(input, _parse, _format, undefined, on_change);\n}\nexport function onChange(event, input, _parse, _format, on_change) {\n  format_input_text(input, _parse, _format, undefined, on_change);\n} // Intercepts \"Delete\" and \"Backspace\" keys.\n// (hitting \"Delete\" or \"Backspace\" at any caret\n//  position should always result in rasing a digit)\n\nexport function onKeyDown(event, input, _parse, _format, on_change) {\n  var operation = getOperation(event);\n\n  switch (operation) {\n    case 'Delete':\n    case 'Backspace':\n      // Intercept this operation and perform it manually.\n      event.preventDefault();\n      var selection = getSelection(input); // If selection is made,\n      // just erase the selected text,\n      // and don't apply any more operations to it.\n\n      if (selection) {\n        erase_selection(input, selection);\n        return format_input_text(input, _parse, _format, undefined, on_change);\n      } // Else, perform the (character erasing) operation manually\n\n\n      return format_input_text(input, _parse, _format, operation, on_change);\n\n    default: // Will be handled when `onChange` fires.\n\n  }\n}\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\n\nfunction erase_selection(input, selection) {\n  var text = input.value;\n  text = text.slice(0, selection.start) + text.slice(selection.end);\n  input.value = text;\n  setCaretPosition(input, selection.start);\n}\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\n\n\nfunction format_input_text(input, _parse, _format, operation, on_change) {\n  // Parse `<input/>` textual value.\n  // Get `value` and `caret` position.\n  var _parse2 = parse(input.value, getCaretPosition(input), _parse),\n      value = _parse2.value,\n      caret = _parse2.caret; // If a user performed an operation (e.g. \"Backspace\", \"Delete\")\n  // then apply that operation and get new `value` and `caret` position.\n\n\n  if (operation) {\n    var operation_applied = edit(value, caret, operation);\n    value = operation_applied.value;\n    caret = operation_applied.caret;\n  } // Format the `value`.\n  // (and reposition the caret accordingly)\n\n\n  var formatted = format(value, caret, _format);\n  var text = formatted.text;\n  caret = formatted.caret; // Set `<input/>` textual value manually\n  // to prevent React from resetting the caret position\n  // later inside subsequent `render()`.\n  // Doesn't work for custom `inputComponent`s for some reason.\n\n  input.value = text; // Position the caret properly.\n\n  setCaretPosition(input, caret); // `<input/>` textual value may have changed,\n  // so the parsed `value` may have changed too.\n  // The `value` didn't neccessarily change\n  // but it might have.\n\n  on_change(value);\n}\n//# sourceMappingURL=input control.js.map"]},"metadata":{},"sourceType":"module"}